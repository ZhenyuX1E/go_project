# 错误码

## 业务错误码

API 接口是直接面向用户的，那么就要求消息返回格式是规范的。其次，如果接口报错，还要能给用户提供一些有用的报错信息，通常需要包含 业务错误码（用来唯一定位一次错误）和业务错误信息（用来描述出错的信息）。这就需要设计一套规范的、科学的错误码。

### 功能需求

为了让用户拥有最好的体验，需要有一个比较好的错误码实现方式，它往往需要包含 2 部分：

- 是有业务错误码标识：因为 HTTP 状态码有限，并且都是跟 HTTP Transport 层相关的，所以还需要业务层独立的业务错误码。一方面，可以根据需要自行扩展，另一方面也能够精准地定位到具体是哪个错误。同时，业务错误码通常是对计算机友好的 10 进制整数，计算机也可以很方便地进行一些分支处理。当然了，业务码也要有一定规则，可以通过业务码迅速定位出是哪类错误。
- 考虑到安全，希望能够对外、对内分别展示不同的错误信息：当开发一个对外的系统，业务出错时，需要一些机制告诉用户出了什么错误，如果能够提供一些帮助文档会更好。但是，不可能把所有的错误都暴露给外部用户，这不仅没必要，也不安全。所以也需要能让我们获取到更详细的内部错误信息的机制，这些内部错误信息可能包含一些敏感的数据，不宜对外展示，但可以协助进行问题定位。所以，需要设计的错误码应该是规范的，能方便客户端感知到 HTTP 是否请求成功，并带有业务码和出错信息。

### 常见实现方式

- 不论请求成功或失败，始终返回 HTTP 状态码 200，在 HTTP Body 中包含用户账号没有找到的错误信息。采用固定返回 HTTP 200 的方式有其合理性，HTTP 状态码通常代表 HTTP Transport 层的状态信息，当收到 HTTP 请求并返回时，表示 HTTP Transport 层是成功的，所以从这个层面上来看 HTTP Status 固定为 200 也是合理的。但这个方式的缺点也很明显：对于每一次请求，都要去解析 HTTP  Body，从中解析出错误码和错误信息。实际上，大部分情况下，对于成功的请求，要么直接转发，要么直接解析到某个结构体中；对于失败的请求，也希望能够更直接地感知到请求失败。这种方式对性能会有一定的影响，对客户端不友好，所以不建议使用这种方式。
- 返回 HTTP 404 Not Found 状态码，并在 Body 中返回简单的错误信息。这种方式比第一种好，通过 HTTP 状态码可以使客户端非常直接地感知到请求失败，并且提供给客户端一些错误信息供参考。但是仅仅靠这些信息，还不能准确地定位和解决问题。
- 返回 HTT 404 Not Found 状态码，并在 Body 中返回详细的错误信息。这种方式比较推荐，既能通过 HTTP 状态码使客户端方便地知道请求出错，又可以使用户根据返回的信息知道哪里出错，以及如何解决问题。同时，返回了机器友好的业务业务码，可以在有需要时让程序进一步判断处理。

### 设计规范

需要在请求出错时，返回详细的信息，通常包括 3 类信息：业务错误码、错误信息和参考文档。

#### 业务错误码规范

在实际开发中，引入业务错误码有下面几个好处：

- 可以非常方便地定位问题和定位代码行（看到错误码知道什么意思、grep  错误码可以定位到错误码所在行、某个错误类型的唯一标识）。
- 错误码包含一定的信息，通过错误码可以判断出错误级别、错误模块和具体错误信息。
- Go 的 net/http 包中只有 60 个错误码，基本都是跟 HTTP 请求相关的错误码。在一个大型系统中，这些错误码完全不够用，而且这些错误码跟业务没有任何关联，满足不了业务的需求，引入业务错误码则可以解决这些问题。业务开发过程中，可能需要判断错误是哪种类型，以便做相应的逻辑处理。

参考新浪的业务错误码设计，总结出了错误码设计规范：纯数字表示，不同部位代表不同的服务、不同的模块。

业务错误码从 100101 开始，其中：

+ 10：服务
+ 01：模块
+ 01：模块自身的错误码序号，每个模块可以注册 100 个错误

##### 服务和模块说明

10 通用为所有服务都适用的错误，提高复用性，避免重复造轮子。

| 服务 | 模块 | 说明(服务 - 模块)                   |
| ---- | ---- | ----------------------------------- |
| 10   | 00   | 通用 - 基本错误                     |
| 10   | 01   | 通用 - 数据库类错误                 |
| 10   | 02   | 通用 - 认证授权类错误               |
| 10   | 03   | 通用 - 加解码类错误                 |
| 11   | 00   | iam-apiserver服务 - 用户模块错误    |
| 11   | 01   | iam-apiserver服务 - 密钥模块错误    |
| 11   | 02   | iam-apiserver服务 - 策略模块错误    |
| 11   | 02   | iam-apiserver服务 - 策略模块错误    |
| 12   | 00   | iam-authz-server服务 - 认证模块错误 |

#### 错误信息规范

错误描述包括：对外的错误描述和对内的错误描述两部分。

##### 对外的错误描述

- 对外暴露的错误，统一大写开头，结尾不要加`.`
- 对外暴露的错误，要简洁，并能准确说明问题
- 对外暴露的错误说明，应该是 `该怎么做` 而不是 `哪里错了`

在下例中，返回中 code 表示业务错误码，message 表示该错误的具体信息。每个错误同时也对应一个 HTTP 状态码，比如上述错误码对应了 HTTP 状态码 500（Internal Server  Error）。另外，在出错时，也返回了 reference 字段，该字段包含了可以解决这个错误的文档链接地址。

```json
{
  "code": 100101,
  "message": "Database error",
  "reference": "https://github.com/rebirthmonkey/docs/guide/zh-CN/faq/xxx"
}
```



##### 对内的错误描述

- 告诉用户他们可以做什么，而不是告诉他们不能做什么。
- 当声明一个需求时，用 must 而不是 should。例如，must be greater than 0、must match regex '[a-z]+'。
- 当声明一个格式不对时，用 must not。例如，must not contain。
- 当声明一个动作时用 may not。例如，may not be specified when otherField is empty、only name may be specified。
- 引用文字字符串值时，请在单引号中指示文字。例如，ust not contain '..'。
- 当引用另一个字段名称时，请在反引号中指定该名称。例如，must be greater than request。
- 指定不等时，请使用单词而不是符号。例如，must be less than 256、must be greater than or equal to 0 (不要用 larger than、bigger than、more than、higher than)。
- 指定数字范围时，请尽可能使用包含范围。
- 建议 Go 1.13 以上，error 生成方式为 fmt.Errorf("module xxx: %w", err)。
- 错误描述用小写字母开头，结尾不要加标点符号。

> 错误信息是直接暴露给用户的，不能包含敏感信息

### 记录规范

在错误产生的最原始位置调用日志，打印错误信息，其它位置直接返回。

当错误发生时，调用 log 包打印错误，通过 log 包的 caller 功能，可以定位到 log 语句的位置，也即能够定位到错误发生的位置。当使用这种方式来打印日志时，需要中遵循以下规范：

- 只在错误产生的最初位置打印日志，其它地方直接返回错误，不需要再对错误进行封装。
- 当代码调用第三方包的函数时，第三方包函数出错时，打印错误信息。比如：

```go
if err := os.Chdir("/root"); err != nil {
    log.Errorf("change dir failed: %v", err)
}
```

### 具体错误码

具体错误码可参考：[错误码](40_error-code.md)，该错误码描述是通过程序自动生成的。


## Lab
### pkg/errors
- [pkg/errors应用](10_pkg-errors/main.go)

### github.com/marmotedu/errors

marmotedu/errors 额外添加了 WrapC() 函数，除了 HTTP 状态码，还添加了业务错误码。

在下例中，通过自定义错误包 errorcode 首先定义了多个业务错误码，并且通过 registry() 函数注册，再在 example 中使用注册的业务错误码堆栈排错。

- [marmotedu/errors应用](20_marmotedu-errors/examples/main.go)
